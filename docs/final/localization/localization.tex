%!TEX program = xelatex

\documentclass[11pt,titlepage]{report}
\input{../../library/import}
\input{../../library/style}
\addbibresource{../../library/bibliography.bib}

\begin{document}

\chapter{Localization}
\label{ch:localization}
An important sub section of the complete system is the localization of KITT. Not only is it important to know whether a waypoint has been reached, the entire control strategy of the car relies on accurate location information. To achieve this, a Time-Difference of Arrival (TDOA) method was employed using audio transmitted by the beacon mounted to the car and received by five microphones placed in the room.

Before the actual localization can take place, several steps must be taken to obtain the TDOAs. First, the transmitted signal must be specified. This is not quite trivial and is explained in section \ref{sec:loc_transmit}. Then, the difference in arrival times between the various microphones must be calculated. This is done by finding peaks (section \ref{sec:loc_peak}) in the propagation channel (section \ref{sec:loc_est_h}). Before the channel can be accurately estimated, it needs to be trimmed to meet specific criteria. These criteria are outlined in section \ref{sec:loc_data_trim}. Finally, once the TDOAs are known, they can be used to calculate the position of the sound source. The algorithm behind this is detailed in section \ref{sec:loc_alg}. Some future considerations which are not currently implemented are discussed in the last paragraph, section \ref{sec:loc_future}.

A general overview of the localization system is shown in figure \ref{fig:localization-overview}. The figure shows the generation of the deconvolution matrix, fed by reference measurements, in the initialization phase of the entire system. Inherent to the design, this matrix needs to be generated only once. The iterative behaviour is called continuously and eventually leads to the localization and angle determination.
\begin{figure}[H]
	\centering
	\includegraphics[width=\linewidth]{resource/localization-overview.pdf}
	\caption{The work flow of the designed localization system}
	\label{fig:localization-overview}
\end{figure}

\section{Transmitted signal}
\label{sec:loc_transmit}
As reported in \cite{epo4-del7} the main goal of the transmitted sequence is to be able to perfectly identify it under every circumstance; even in the presence of noise or signals emitted by other beacons. Only some parameters of the transmitted signal can be changed; for example it is already defined to be an OOK signal. The tweaking parameters are the carrier frequency, the code frequency, the repetition frequency and the code word (and thus its length). More details on the choice of the sequence is given in \cite{epo4-del7} but the conclusions are summarized in table \ref{tab:loc_signal}.

Using the given microcontroller programmer, the thus defined reference signal was programmed onto KITT.

% TODO fix this table!
\begin{table}[H]
\centering
\begin{tabular}{c | c | c}
\hline \hline
Parameter & Choice & Reasoning \\
\hline
Carrier frequency & \SI{15}{khz} & 
Chosen frequency is high enough to prevent most interference with human speech but low enough that the beacon can accurately represent it.\\
Code frequency & \SI{5}{khz} & High code frequency may lead to inaccurate measurements. This setting proved to work in practice.\\
Repeat frequency & \SI{8}{hz} & Higher repeat frequency guarantees more frequent localization but leaves less room between samples. In \cite{epo4-del7} it was shown that this setting is optimal.\\
Code word & \texttt{4eeb428c} & A randomly generated hexadecimal string.\\
\end{tabular}
\caption{Summary of chosen audio beacon parameters}
\label{tab:loc_signal}
\end{table}

\section{Recording and data trimming}
\label{sec:loc_data_trim}
The recording stage is the gateway between the physical sound and the digital signal processing. Each microphone is recorded using an audio interface connected via USB to the computer at a sample rate of \SI{48}{\kilo\hertz}. Since the localization should be done as often as possible to get accurate results, the recording process should take as little time as possible yet still guarantee the presence of a complete response. Therefore, the recording time was set to two times the repeat time, e.g. \SI{250}{\milli\second}. If the recording would start exactly at the first received peak, no data trimming would be necessary. But because the recording is not synchronized to the emitted sound we have no method of verifying this. Therefore the data must first be trimmed.

Data trimming is done for two reasons: \textbf{(1)}, the recorded data must not include sound sent by a previous pulse (ideally including reflections) and \textbf{(2)}, the signal we wish to deconvolve must be a causal response to the \SI{1}{\centi\meter} reference measurements. \textbf{(1)} was guaranteed by truncating the recording to a limited interval around the peak in the highest quality channel estimate. As a measure for channel quality $\frac{\text{max}(h[n])}{\text{std}(h[n])}$ was used since this gives a quick indication of the signal to noise ratio. Then, a similar peak detection algorithm as described in section \ref{sec:loc_peak} was used to find the peak value in the channel. The interval the signal was truncated to is given by the field dimensions: since the expectation is that KITT should not leave the field the maximum distance a sound pulse must travel is diagonally across the field. Since this distance is known (\SI{49}{\meter\squared}), the speed of sound is known (\SI{343}{\meter\per\second}) and the sample frequency of the audio interface is known (\SI{48}{\kilo\hertz}), the delay between peaks can be no more than \num{1400} samples. Further more, the highest quality signal is likely to be closer to a microphone so it makes sense not to \textit{center} the search interval around the peak sample, but to bias it more towards the samples following the peak. Therefore, calling the sample at which the highest quality peak is detected $t_0$ and allowing some headroom, the search interval was set to $[t_0 - 400, t_0 +1500]$.

\section{Channel estimation}
\label{sec:loc_est_h}
Channel estimation is done using matrix inversion as described in the manual \cite{epo4-manual}. The matched filter approach was also tested but proved to be less reliable because the obtained channel responses had no clear peak. Summarizing from \cite{epo4-manual} and \cite{epo4-del7}, a signal $y[n]=x[n]*h[n]$ is received at every microphone. The deconvolution method then approximates $h[n]$ as $\vec{\hat{h}}=(\mat{X}^T\mat{X})^{-1}\mat{X}^T\vec{y}$, where $\mat{X}$ is a matrix in Toeplitz form as outlined in \cite{epo4-manual}. Because the sent signal is known, the matrix $\mat{X}^\dagger=(\mat{X}^T\mat{X})^{-1}\mat{X}^T$ can be calculated beforehand. In practical implementations, this matrix must be computed for every microphone because the response of each matrix will vary slightly. Therefore, the matrix was computed for every microphone using recordings of the training sequence which were recorded at \SI{1}{cm} distance from that microphone.

The size of the resulting matrix $\mat{X}^\dagger$ is dependent on the amount of microphones used, the estimated length of the channel, $L$, and the length of the \SI{1}{cm} recordings, $N_x$. Because the number of microphones is fixed at \num{5}, the calculation of $\mat{X}^\dagger$ can only be sped up by reducing the size (and thus accuracy) of the deconvolution matrix and accuracy increased by increasing $L$ and $N_x$. This is a complicated trade-off that must be made and tailored to the hardware used. The used settings for KITT are $L=3500$ and $N_x=500$, which allow good deconvolution properties, but leaves $\mat{X}^\dagger$ to be calculated within a few minutes on modern computers.

A potential problem to the matrix inversion necessary for the calculation of $\mat{X}^\dagger$ is when the matrix $\mat{A}=\mat{X}^T\mat{X}$ is singular or ill-conditioned. When $\mat{A}$ is singular (the determinant of $\mat{A}$ is zero), $\mat{X}^\dagger$ cannot be calculated and when $\mat{A}$ is ill-conditioned\footnote{A matrix is said to be ill-conditioned if the ratio of the largest singular value to the smallest singular value (the condition number) $c=\frac{\sigma_1}{\sigma_n}$ is `large'. Though `large' is not well-defined itself, it can be shown \cite{epo4-manual} that an error $\epsilon$ in the input to a linear system is potentially magnified by the condition number in the solution.} the resulting matrix is dominated by small singular values. In order to overcome this potential problem, a singular value filter was built into the matrix inversion algorithm. The filter works as follows:
Let $\mat{A}=\mat{U}\mat{\Sigma}\mat{V}^T$ be the singular value decomposition of $\mat{A}=\mat{X}^T\mat{X}$ where $\mat{A}$ is of size $m\times n$. Then $\mat{\Sigma}$ is a diagonal matrix of size $m \times n$ containing the singular values $\sigma_1, \sigma_2, ..., \sigma_n$ of $\mat{A}$ on the diagonal in descending order. For any $\sigma_i<t$, where $t$ is some threshold, the left inverse of $\mat{A}$ is approximated by $\mat{\hat{A}}^\dagger=\mat{\hat{V}}\mat{\hat{\Sigma}}^{-1}\mat{\hat{U}}^T$ where $\mat{\hat{V}}$, $\mat{\hat{\Sigma}}$ and $\mat{\hat{U}}$ are their respective matrices as defined before with the $i^\text{th}$ columns removed. 

The choice of threshold $t$ is non-trivial and was determined using trial and error on measurement data. We discovered that the `optimal' threshold was slightly different for each microphone and even each measurement. An important insight is that when the threshold is set too high, e.g. too large singular values are filtered, some calculated channel responses are no longer identifiable as such. Specifically, the result would be a modulated sine wave. In order to prevent this from happening during the demonstration, the thresholds for each microphone channel were chosen somewhat conservative, see table \ref{tab:loc_svd_value}.

% TODO: check values in table
% TODO: include reference to channel estimation matlab

\begin{table}[H]
\centering
\begin{tabular}{ c | c}
\hline \hline
Microphone channel & Singular value threshold $t$ \\
\hline
1 & \num{0.1} \\ 
2 & \num{0.2} \\
3 & \num{0.5} \\
4 & \num{0.2} \\
5 & \num{0.015} \\
\end{tabular}
\caption{Singular value threshold for each microphone channel}
\label{tab:loc_svd_value}
\end{table}

\section{Peak detection}
\label{sec:loc_peak}
The previous report \cite{epo4-del7} described two methods of localizing the peaks in the estimated channel, the first based on \texttt{MATLAB}'s \texttt{findpeaks} function and the second based on smart utilization of the standard deviation of the channel. However, after revising the code it seemed both these approaches were too time consuming. It was decided instead to implement a simpler detection algorithm which simply scans the estimated channel sample by sample and compares the amplitude to some threshold which is proportional to the maximum of all samples. After some simple testing on synthetic data this turned out to be up to a factor \num{40} faster than the \texttt{findpeaks} implementation. Since the standard deviation approach was already at least a factor \num{10} slower than the \texttt{findpeaks} algorithm, it was decided to use the threshold approach. 
% TODO insert reference to find_start.m
A plot of an arbitrary recovered impulse response is shown in figure \ref{fig:localization-typical-impulse}. In green the work of the peak detection algorithm is shown. 

\begin{figure}[H]
	\centering
	\includegraphics[width=0.5\linewidth]{resource/typical-impulse.pdf}
	\caption{A typical impulse response along with the detected peak}
	\label{fig:localization-typical-impulse}
\end{figure}

\section{Localization algorithm}
\label{sec:loc_alg}
Once the peaks have been detected in all five microphone channels, a range difference matrix can be constructed consisting of entries $r(i,j)$ corresponding to the range difference between microphones $i$~and~$j$. Obviously, the diagonal is zero. 
% TODO: add reference to getrangematrix.m
Using the range difference matrix $\mat{R}$ we can construct a matrix $\mat{A}$, a vector $\vec{x}$ and a vector $\vec{b}$ as in \cite{epo4-manual}, $\mat{A}\vec{x}=\vec{b}$ rows of $\mat{A}$ are constructed for each microphone pair $(i,j)$ as
\begin{equation}
\begin{bmatrix}
2(\vec{x}_j-\vec{x}_i)^T & -2r_{i,j}
\end{bmatrix}
\end{equation}

The entries of vector $\vec{b}$ are also constructed for each microphone pair as
\begin{equation}
\begin{bmatrix}
r_{i,j}^2-||\vec{x}_i||^2+||\vec{x}_j||^2
\end{bmatrix}
\end{equation}

The vector $\vec{x}$ that solves these equations may not exist because the system is overdetermined: there are \num{5} microphones (so $\mat{A}$ has \num{10} rows) and we limit ourself to two coordinates yielding \num{6} columns in $\mat{A}$. Therefore, the solution $\vec{x}$ is calculated (much in the same way as in section \ref{sec:loc_est_h}) as the solution of the matrix equation $\mat{A}\vec{x}=\vec{b}$ in an ordinary least squares way: $\vec{x}=(\mat{A}^T\mat{A})^{-1}\mat{A}^T\vec{b}$. This method yields an exact solution if it exists and otherwise produces the $\vec{x}$ with the least squares error. The first two entries of $\vec{x}$ are the resulting position of KITT. 
% TODO: include reference to localize.m

The angle at which KITT is driving through the field, $\theta$, can be calculated from the current and previous location. Let $\vec{x}_n=\begin{bmatrix}x_n\\y_n\end{bmatrix}$ be the latest determined position and $\vec{x}_{n-1}=\begin{bmatrix}x_{n-1}\\y_{n-1}\end{bmatrix}$ the previous location, then $\theta$ is given by
\begin{equation}
\theta = \tan^{-1}\left(\frac{y_n-y_{n-1}}{x_n-x_{n-1}}\right)
\end{equation}




\section{Future work}
\label{sec:loc_future}
Explain other methods we tried, e.g. Bancroft, MDS etc.
\end{document}